"""
RaazGPT ‚Äî Offline All‚Äëin‚ÄëOne Chatbot (Smarter v2)
--------------------------------------------------
‚úÖ Fully offline (no internet, no APIs)
‚úÖ GUI (Tkinter) with chatbox, input, Send + Voice buttons
‚úÖ Voice input (speech_recognition) + TTS (pyttsx3) if installed
‚úÖ Memory: name, emotion, usage stats ‚Üí memory.json
‚úÖ ~3000 auto‚Äëgenerated Q/A (GK, Science, History, Simple Math)
‚úÖ Fuzzy search + intent router + math solver
‚úÖ Commands: /help, /clear, /export, /name <X>, /emotion <X>, /stats
‚úÖ Quality fixes: de-dupe, better normalization, safe threading

Run:  python raazgpt_offline_v2.py
"""

import os
import json
import random
import re
import time
import threading
import queue
import difflib
import tkinter as tk
from tkinter import scrolledtext, messagebox, filedialog

# Optional voice libs (try import; GUI still works if missing)
try:
    import speech_recognition as sr
    SR_AVAILABLE = True
except Exception:
    SR_AVAILABLE = False

try:
    import pyttsx3
    TTS_AVAILABLE = True
except Exception:
    TTS_AVAILABLE = False

# ------------------ Config ------------------
MEMORY_FILE = "memory.json"
QA_CACHE_FILE = "qa_cache.json"
TARGET_QA_COUNT = 3000
RANDOM_SEED = 42
VOICE_ENABLED = SR_AVAILABLE and TTS_AVAILABLE
FUZZY_THRESHOLD = 0.86  # 0..1 higher = stricter

random.seed(RANDOM_SEED)

# ------------------ Utilities ------------------
def safe_print(*args, **kwargs):
    try:
        print(*args, **kwargs)
    except Exception:
        pass

_tts_engine = None

def speak(text):
    """Text to speech (non-blocking) if available."""
    if not TTS_AVAILABLE:
        return
    global _tts_engine
    if _tts_engine is None:
        try:
            _tts_engine = pyttsx3.init()
        except Exception as e:
            safe_print("TTS init error:", e)
            return
    try:
        _tts_engine.say(text)
        _tts_engine.runAndWait()
    except Exception as e:
        safe_print("TTS error:", e)


def listen(timeout=4, phrase_time_limit=6):
    """Listen once from microphone and return recognized Hindi text (if SR available)."""
    if not SR_AVAILABLE:
        return ""
    r = sr.Recognizer()
    try:
        with sr.Microphone() as source:
            r.adjust_for_ambient_noise(source, duration=0.6)
            safe_print("üé§ Listening‚Ä¶")
            audio = r.listen(source, timeout=timeout, phrase_time_limit=phrase_time_limit)
    except Exception as e:
        safe_print("Mic/timeout error:", e)
        return ""
    try:
        text = r.recognize_google(audio, language='hi-IN')
        safe_print("Heard:", text)
        return text
    except Exception as e:
        safe_print("Recognition error:", e)
        return ""


def normalize(s: str) -> str:
    if not s:
        return ""
    s = s.strip().lower()
    # Keep math operators, remove other punctuations
    s = re.sub(r"[^\w\s\+\-\*\/]", "", s)
    # Collapse spaces
    s = re.sub(r"\s+", " ", s)
    return s

# ------------------ Memory ------------------
def load_memory():
    if os.path.exists(MEMORY_FILE):
        try:
            with open(MEMORY_FILE, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception:
            return {}
    return {}


def save_memory():
    try:
        with open(MEMORY_FILE, "w", encoding="utf-8") as f:
            json.dump(memory, f, ensure_ascii=False, indent=2)
    except Exception as e:
        safe_print("Save memory error:", e)


memory = load_memory()
memory.setdefault("name", None)
memory.setdefault("emotion", "neutral")
memory.setdefault("stats", {"messages": 0, "jokes": 0, "songs": 0})
memory.setdefault("last_seen", int(time.time()))

# ------------------ Small curated facts ------------------
# NOTE: Keep these clean & accurate. (Hindi is ‡§∞‡§æ‡§ú‡§≠‡§æ‡§∑‡§æ, not '‡§∞‡§æ‡§∑‡•ç‡§ü‡•ç‡§∞‡•Ä‡§Ø ‡§≠‡§æ‡§∑‡§æ'.)
curated_facts = [
    ("‡§≠‡§æ‡§∞‡§§ ‡§ï‡•Ä ‡§∞‡§æ‡§ú‡§ß‡§æ‡§®‡•Ä ‡§ï‡•ç‡§Ø‡§æ ‡§π‡•à", "‡§®‡§à ‡§¶‡§ø‡§≤‡•ç‡§≤‡•Ä"),
    ("‡§≠‡§æ‡§∞‡§§ ‡§ï‡•Ä ‡§∞‡§æ‡§ú‡§≠‡§æ‡§∑‡§æ ‡§ï‡•ç‡§Ø‡§æ ‡§π‡•à", "‡§π‡§ø‡§®‡•ç‡§¶‡•Ä (‡§¶‡•á‡§µ‡§®‡§æ‡§ó‡§∞‡•Ä ‡§≤‡§ø‡§™‡§ø) ‡§î‡§∞ ‡§Ö‡§Ç‡§ó‡•ç‡§∞‡•á‡§ú‡§º‡•Ä ‡§∏‡§π‡§æ‡§Ø‡§ï ‡§≠‡§æ‡§∑‡§æ"),
    ("‡§≠‡§æ‡§∞‡§§ ‡§ï‡§æ ‡§∞‡§æ‡§∑‡•ç‡§ü‡•ç‡§∞‡•Ä‡§Ø ‡§™‡§∂‡•Å ‡§ï‡•å‡§® ‡§∏‡§æ ‡§π‡•à", "‡§¨‡§æ‡§ò"),
    ("‡§≠‡§æ‡§∞‡§§ ‡§ï‡§æ ‡§∞‡§æ‡§∑‡•ç‡§ü‡•ç‡§∞‡•Ä‡§Ø ‡§™‡§ï‡•ç‡§∑‡•Ä ‡§ï‡•å‡§® ‡§∏‡§æ ‡§π‡•à", "‡§Æ‡•ã‡§∞"),
    ("‡§≠‡§æ‡§∞‡§§ ‡§ï‡§æ ‡§∞‡§æ‡§∑‡•ç‡§ü‡•ç‡§∞‡•Ä‡§Ø ‡§´‡•Ç‡§≤ ‡§ï‡•å‡§® ‡§∏‡§æ ‡§π‡•à", "‡§ï‡§Æ‡§≤"),
    ("‡§≠‡§æ‡§∞‡§§ ‡§ï‡§æ ‡§∞‡§æ‡§∑‡•ç‡§ü‡•ç‡§∞‡•Ä‡§Ø ‡§´‡§≤ ‡§ï‡•å‡§® ‡§∏‡§æ ‡§π‡•à", "‡§Ü‡§Æ"),
    ("‡§≠‡§æ‡§∞‡§§ ‡§ï‡§æ ‡§∞‡§æ‡§∑‡•ç‡§ü‡•ç‡§∞‡•Ä‡§Ø ‡§µ‡•É‡§ï‡•ç‡§∑ ‡§ï‡•å‡§® ‡§∏‡§æ ‡§π‡•à", "‡§¨‡§∞‡§ó‡§¶"),
    ("‡§≠‡§æ‡§∞‡§§ ‡§ï‡§æ ‡§Æ‡•Å‡§¶‡•ç‡§∞‡§æ ‡§ï‡•ç‡§Ø‡§æ ‡§π‡•à", "‡§≠‡§æ‡§∞‡§§‡•Ä‡§Ø ‡§∞‡•Å‡§™‡§Ø‡§æ"),
    ("‡§§‡§æ‡§ú‡§Æ‡§π‡§≤ ‡§ï‡§ø‡§∏‡§®‡•á ‡§¨‡§®‡§µ‡§æ‡§Ø‡§æ", "‡§∂‡§æ‡§π‡§ú‡§π‡§æ‡§Å"),
    ("‡§≠‡§æ‡§∞‡§§‡•Ä‡§Ø ‡§∏‡§Ç‡§µ‡§ø‡§ß‡§æ‡§® ‡§ï‡§¨ ‡§≤‡§æ‡§ó‡•Ç ‡§π‡•Å‡§Ü", "26 ‡§ú‡§®‡§µ‡§∞‡•Ä 1950"),
    ("ISRO ‡§ï‡•Ä ‡§∏‡•ç‡§•‡§æ‡§™‡§®‡§æ ‡§ï‡§¨ ‡§π‡•Å‡§à", "1969"),
    ("‡§≠‡§æ‡§∞‡§§ ‡§ï‡§æ ‡§™‡§π‡§≤‡§æ ‡§â‡§™‡§ó‡•ç‡§∞‡§π ‡§ï‡•å‡§® ‡§∏‡§æ ‡§•‡§æ", "‡§Ü‡§∞‡•ç‡§Ø‡§≠‡§ü‡•ç‡§ü"),
    ("‡§ö‡§Ç‡§¶‡•ç‡§∞‡§Ø‡§æ‡§®3 ‡§ï‡§¨ ‡§≤‡•â‡§®‡•ç‡§ö ‡§π‡•Å‡§Ü", "2023"),
    ("‡§≠‡§æ‡§∞‡§§‡•Ä‡§Ø ‡§∞‡§ø‡§ú‡§∞‡•ç‡§µ ‡§¨‡•à‡§Ç‡§ï ‡§ï‡•Ä ‡§∏‡•ç‡§•‡§æ‡§™‡§®‡§æ ‡§ï‡§¨ ‡§π‡•Å‡§à", "1935"),
    ("‡§≠‡§æ‡§∞‡§§‡•Ä‡§Ø ‡§∏‡§Ç‡§∏‡§¶ ‡§ï‡•á ‡§∏‡§¶‡§® ‡§ï‡•å‡§® ‡§∏‡•á ‡§π‡•à‡§Ç", "‡§≤‡•ã‡§ï‡§∏‡§≠‡§æ ‡§î‡§∞ ‡§∞‡§æ‡§ú‡•ç‡§Ø‡§∏‡§≠‡§æ"),
    ("‡§≠‡§æ‡§∞‡§§‡•Ä‡§Ø ‡§™‡•ç‡§∞‡§ß‡§æ‡§®‡§Æ‡§Ç‡§§‡•ç‡§∞‡•Ä ‡§ï‡§æ ‡§®‡§ø‡§µ‡§æ‡§∏ ‡§∏‡•ç‡§•‡§æ‡§® ‡§ï‡•ç‡§Ø‡§æ ‡§ï‡§π‡§≤‡§æ‡§§‡§æ ‡§π‡•à", "‡§≤‡•ã‡§ï ‡§ï‡§≤‡•ç‡§Ø‡§æ‡§£ ‡§Æ‡§æ‡§∞‡•ç‡§ó"),
    ("UNO ‡§ï‡§æ ‡§Æ‡•Å‡§ñ‡•ç‡§Ø‡§æ‡§≤‡§Ø ‡§ï‡§π‡§æ‡§Å ‡§π‡•à", "‡§®‡•ç‡§Ø‡•Ç‡§Ø‡•â‡§∞‡•ç‡§ï"),
    ("WHO ‡§ï‡§æ ‡§Æ‡•Å‡§ñ‡•ç‡§Ø‡§æ‡§≤‡§Ø ‡§ï‡§π‡§æ‡§Å ‡§π‡•à", "‡§ú‡§ø‡§®‡•á‡§µ‡§æ"),
    ("‡§ó‡§Ç‡§ó‡§æ ‡§ï‡§æ ‡§â‡§¶‡•ç‡§ó‡§Æ ‡§∏‡•ç‡§•‡§≤ ‡§ï‡§π‡§æ‡§Å ‡§π‡•à", "‡§ó‡§Ç‡§ó‡•ã‡§§‡•ç‡§∞‡•Ä ‡§π‡§ø‡§Æ‡§®‡§¶"),
    ("‡§≠‡§æ‡§∞‡§§ ‡§ï‡§æ ‡§∏‡§¨‡§∏‡•á ‡§¨‡§°‡§º‡§æ ‡§∞‡§æ‡§ú‡•ç‡§Ø ‡§ï‡•å‡§® ‡§∏‡§æ ‡§π‡•à", "‡§∞‡§æ‡§ú‡§∏‡•ç‡§•‡§æ‡§®"),
    ("‡§≠‡§æ‡§∞‡§§ ‡§ï‡§æ ‡§∏‡§¨‡§∏‡•á ‡§õ‡•ã‡§ü‡§æ ‡§∞‡§æ‡§ú‡•ç‡§Ø ‡§ï‡•å‡§® ‡§∏‡§æ ‡§π‡•à", "‡§ó‡•ã‡§µ‡§æ"),
    ("‡§µ‡§ø‡§∂‡•ç‡§µ ‡§ï‡§æ ‡§∏‡§¨‡§∏‡•á ‡§¨‡§°‡§º‡§æ ‡§Æ‡§π‡§æ‡§∏‡§æ‡§ó‡§∞ ‡§ï‡•å‡§® ‡§∏‡§æ ‡§π‡•à", "‡§™‡•ç‡§∞‡§∂‡§æ‡§Ç‡§§ ‡§Æ‡§π‡§æ‡§∏‡§æ‡§ó‡§∞"),
    ("‡§µ‡§ø‡§∂‡•ç‡§µ ‡§ï‡•Ä ‡§∏‡§¨‡§∏‡•á ‡§≤‡§Ç‡§¨‡•Ä ‡§®‡§¶‡•Ä ‡§ï‡•å‡§® ‡§∏‡•Ä ‡§π‡•à", "‡§®‡•Ä‡§≤"),
    ("‡§è‡§µ‡§∞‡•á‡§∏‡•ç‡§ü ‡§ï‡•Ä ‡§ä‡§Å‡§ö‡§æ‡§à ‡§ï‡§ø‡§§‡§®‡•Ä ‡§π‡•à", "8848.86 ‡§Æ‡•Ä‡§ü‡§∞"),
    ("‡§≠‡§æ‡§∞‡§§ ‡§ï‡§æ ‡§™‡§π‡§≤‡§æ 3D ‡§™‡•ç‡§∞‡§ø‡§Ç‡§ü‡•á‡§° ‡§™‡•ã‡§∏‡•ç‡§ü ‡§ë‡§´‡§ø‡§∏ ‡§ï‡§π‡§æ‡§Å ‡§π‡•à", "‡§¨‡•á‡§Ç‡§ó‡§≤‡•Å‡§∞‡•Å"),
]

jokes = [
    "‡§ü‡•Ä‡§ö‡§∞: ‡§á‡§§‡§®‡•á ‡§∏‡•Å‡§∏‡•ç‡§§ ‡§ï‡•ç‡§Ø‡•ã‡§Ç ‡§π‡•ã? ‡§õ‡§æ‡§§‡•ç‡§∞: ‡§∏‡§∞, ‡§∏‡•Å‡§∏‡•ç‡§§‡•Ä ‡§≠‡•Ä ‡§è‡§ï ‡§ï‡§≤‡§æ ‡§π‡•à!",
    "‡§°‡•â‡§ï‡•ç‡§ü‡§∞: ‡§¶‡§µ‡§æ ‡§ñ‡§æ ‡§≤‡•Ä? ‡§Æ‡§∞‡•Ä‡§ú: ‡§ú‡•Ä, ‡§™‡§∞ ‡§Ö‡§¨ ‡§≠‡•Ç‡§ñ ‡§®‡§π‡•Ä‡§Ç ‡§≤‡§ó ‡§∞‡§π‡•Ä‚Ä¶ ‡§¶‡§µ‡§æ ‡§¨‡§π‡•Å‡§§ ‡§∏‡•ç‡§µ‡§æ‡§¶‡§ø‡§∑‡•ç‡§ü ‡§•‡•Ä!",
    "‡§è‡§ï ‡§¶‡•ã‡§∏‡•ç‡§§: ‡§Æ‡•à‡§Ç ‡§ï‡§≤ ‡§∏‡•á ‡§°‡§æ‡§á‡§ü ‡§™‡§∞ ‡§π‡•Ç‡§Å‡•§ ‡§¶‡•Ç‡§∏‡§∞‡§æ: ‡§ï‡§ø‡§∏ ‡§∏‡§Æ‡§Ø? ‡§™‡§π‡§≤‡§æ: ‡§∏‡•ã‡§§‡•á ‡§∏‡§Æ‡§Ø‡•§",
]

songs = [
    "‡§§‡•Å‡§Æ ‡§π‡•Ä ‡§π‡•ã‚Ä¶ ‡§¨‡§∏ ‡§§‡•Å‡§Æ ‡§π‡•Ä ‡§π‡•ã‚Ä¶",
    "‡§Æ‡•á‡§∞‡•á ‡§∞‡§Ç‡§ó ‡§Æ‡•á‡§Ç ‡§∞‡§Ç‡§ó‡§®‡•á ‡§µ‡§æ‡§≤‡•Ä‚Ä¶",
    "‡§ö‡§æ‡§Å‡§¶ ‡§∏‡§æ ‡§∞‡•ã‡§∂‡§® ‡§ö‡•á‡§π‡§∞‡§æ‚Ä¶",
]

# ------------------ Dataset generation ------------------

def generate_variants(question: str):
    q = question.strip().rstrip(' ?')
    base = [q, q + " ‡§ï‡•ç‡§Ø‡§æ ‡§π‡•à", "‡§¨‡§§‡§æ‡§á‡§è: " + q, q + " ‡§¨‡§§‡§æ‡§á‡§è", "‡§ï‡§π‡§ø‡§è, " + q]
    if len(q.split()) <= 6:
        base += ["‡§ï‡•å‡§® ‡§∏‡§æ " + q, "‡§ï‡•å‡§® ‡§π‡•à " + q]
    # De-dup while preserving order
    seen = set()
    out = []
    for x in base:
        k = normalize(x)
        if k not in seen:
            seen.add(k)
            out.append(x)
    return out


def gen_math_questions(count=1800):
    mq = []
    ops = ['+', '-', '*', '/']
    for _ in range(count):
        a = random.randint(1, 999)
        b = random.randint(1, 999)
        op = random.choice(ops)
        if op == '/':
            b = random.randint(1, 20)
            a = b * random.randint(1, 20)
        expr = f"{a} {op} {b}"
        try:
            if op == '/':
                val = a / b
                ans = str(int(val)) if abs(val - round(val)) < 1e-9 else str(round(val, 2))
            else:
                ans = str(int(eval(expr)))
        except Exception:
            continue
        mq.append((expr + " = ?", ans))
    return mq


def build_large_qa():
    # Try cached build for speed
    if os.path.exists(QA_CACHE_FILE):
        try:
            with open(QA_CACHE_FILE, "r", encoding="utf-8") as f:
                data = json.load(f)
                if isinstance(data, list) and len(data) >= 1000:
                    return [(q, a) for q, a in data]
        except Exception:
            pass

    qa = []
    # 1) expand curated facts
    for q, a in curated_facts:
        for v in generate_variants(q):
            qa.append((v, a))

    # 2) some direct GK
    more = [
        ("‡§≠‡§æ‡§∞‡§§ ‡§ï‡§æ ‡§∞‡§æ‡§∑‡•ç‡§ü‡•ç‡§∞‡•Ä‡§Ø ‡§ñ‡•á‡§≤ ‡§ï‡•ç‡§Ø‡§æ ‡§π‡•à", "‡§π‡•â‡§ï‡•Ä"),
        ("‡§≠‡§æ‡§∞‡§§ ‡§ï‡•Ä ‡§Æ‡•Å‡§¶‡•ç‡§∞‡§æ ‡§ï‡•ç‡§Ø‡§æ ‡§π‡•à", "‡§≠‡§æ‡§∞‡§§‡•Ä‡§Ø ‡§∞‡•Å‡§™‡§Ø‡§æ"),
        ("‡§§‡§æ‡§ú‡§Æ‡§π‡§≤ ‡§ï‡§π‡§æ‡§Å ‡§π‡•à", "‡§Ü‡§ó‡§∞‡§æ"),
        ("‡§≠‡§æ‡§∞‡§§‡•Ä‡§Ø ‡§∏‡§Ç‡§µ‡§ø‡§ß‡§æ‡§® ‡§ï‡•á ‡§™‡§ø‡§§‡§æ ‡§ï‡•å‡§® ‡§π‡•à‡§Ç", "‡§°‡•â. ‡§≠‡•Ä‡§Æ‡§∞‡§æ‡§µ ‡§Ö‡§Ç‡§¨‡•á‡§°‡§ï‡§∞"),
        ("‡§ö‡§Ç‡§¶‡•ç‡§∞‡§Ø‡§æ‡§®3 ‡§ï‡§æ ‡§≤‡•à‡§Ç‡§°‡§ø‡§Ç‡§ó ‡§ï‡•ç‡§∑‡•á‡§§‡•ç‡§∞", "‡§ö‡§Ç‡§¶‡•ç‡§∞‡§Æ‡§æ ‡§ï‡§æ ‡§¶‡§ï‡•ç‡§∑‡§ø‡§£ ‡§ß‡•ç‡§∞‡•Å‡§µ"),
    ]
    for q, a in more:
        qa.append((q, a))
        qa.append((q + " ‡§¨‡§§‡§æ‡§á‡§è", a))

    # 3) math autogen
    qa.extend(gen_math_questions(1800))

    # 4) triggers
    for t in ["‡§Æ‡§ú‡§æ‡§ï", "‡§Æ‡§ú‡§æ‡§ï ‡§∏‡•Å‡§®‡§æ‡§ì", "‡§ï‡•ã‡§à ‡§ú‡•ã‡§ï", "‡§ú‡•ã‡§ï ‡§∏‡•Å‡§®‡§æ‡§ì"]:
        qa.append((t, "__JOKE__"))
    for t in ["‡§ó‡§æ‡§®‡§æ", "‡§ó‡§æ‡§®‡§æ ‡§∏‡•Å‡§®‡§æ‡§ì", "‡§ï‡•ã‡§à ‡§ó‡§æ‡§®‡§æ", "‡§∏‡•â‡§®‡•ç‡§ó"]:
        qa.append((t, "__SONG__"))

    # 5) pad until target with variants of facts
    fact_only = [q for q, _ in curated_facts]
    while len(qa) < TARGET_QA_COUNT and fact_only:
        base = random.choice(fact_only)
        a = next(ans for q, ans in curated_facts if q == base)
        for v in generate_variants(base):
            qa.append((v, a))
            if len(qa) >= TARGET_QA_COUNT:
                break

    # de-dup preserve order
    seen = set()
    uniq = []
    for q, a in qa:
        key = (normalize(q), str(a).strip().lower())
        if key not in seen:
            seen.add(key)
            uniq.append((q.strip(), a))

    # cache
    try:
        with open(QA_CACHE_FILE, "w", encoding="utf-8") as f:
            json.dump(uniq, f, ensure_ascii=False)
    except Exception:
        pass

    return uniq


safe_print("Generating large offline QA dataset‚Ä¶")
QA_LIST = build_large_qa()
safe_print(f"Generated {len(QA_LIST)} QA entries.")

# For fuzzy search we maintain a list of just questions
QA_QUESTIONS = [q for q, _ in QA_LIST]

# ------------------ Intent Router ------------------
class IntentRouter:
    def __init__(self):
        self.patterns = [
            (re.compile(r"^(/help|help|‡§Æ‡§¶‡§¶)$", re.I), self.intent_help),
            (re.compile(r"^/clear$", re.I), self.intent_clear),
            (re.compile(r"^/export$", re.I), self.intent_export),
            (re.compile(r"^/name\s+(.+)$", re.I), self.intent_set_name),
            (re.compile(r"^/emotion\s+(.+)$", re.I), self.intent_set_emotion),
            (re.compile(r"^/stats$", re.I), self.intent_stats),
            (re.compile(r"^(hi|hello|namaste|‡§®‡§Æ‡§∏‡•ç‡§§‡•á)$", re.I), self.intent_greet),
        ]

    # --- intents ---
    def intent_help(self, match, text):
        return (
            "Commands:\n"
            "/help ‚Äî ‡§Ø‡§π ‡§Æ‡§¶‡§¶\n"
            "/clear ‚Äî ‡§ö‡•à‡§ü ‡§∏‡§æ‡§´ ‡§ï‡§∞‡•á‡§Ç\n"
            "/export ‚Äî ‡§ö‡•à‡§ü ‡§ï‡•ã .txt ‡§Æ‡•á‡§Ç ‡§∏‡•á‡§µ ‡§ï‡§∞‡•á‡§Ç\n"
            "/name <‡§Ü‡§™‡§ï‡§æ ‡§®‡§æ‡§Æ> ‚Äî ‡§Ü‡§™‡§ï‡§æ ‡§®‡§æ‡§Æ ‡§∏‡•á‡§µ\n"
            "/emotion <happy/sad/neutral> ‚Äî ‡§≠‡§æ‡§µ‡§®‡§æ ‡§∏‡•á‡§ü\n"
            "/stats ‚Äî ‡§â‡§™‡§Ø‡•ã‡§ó ‡§Ü‡§Å‡§ï‡•ú‡•á"
        )

    def intent_clear(self, match, text):
        clear_chat()
        return "‡§ö‡•à‡§ü ‡§∏‡§æ‡§´ ‡§ï‡§∞ ‡§¶‡•Ä ‡§ó‡§à‡•§"

    def intent_export(self, match, text):
        return export_chat()

    def intent_set_name(self, match, text):
        name = match.group(1).strip()
        memory["name"] = name
        save_memory()
        return f"‡§†‡•Ä‡§ï ‡§π‡•à {name}, ‡§Ü‡§™‡§ï‡§æ ‡§®‡§æ‡§Æ ‡§∏‡•á‡§µ ‡§π‡•ã ‡§ó‡§Ø‡§æ!"

    def intent_set_emotion(self, match, text):
        emo = match.group(1).strip().lower()
        memory["emotion"] = emo
        save_memory()
        return f"‡§≠‡§æ‡§µ‡§®‡§æ '{emo}' ‡§∏‡•á‡§ü ‡§ï‡§∞ ‡§¶‡•Ä‡•§"

    def intent_stats(self, match, text):
        st = memory.get("stats", {})
        return f"‡§∏‡§Ç‡§¶‡•á‡§∂: {st.get('messages',0)}, ‡§ú‡•ã‡§ï‡•ç‡§∏: {st.get('jokes',0)}, ‡§ó‡§æ‡§®‡•á: {st.get('songs',0)}"

    def intent_greet(self, match, text):
        if memory.get("name"):
            return f"‡§®‡§Æ‡§∏‡•ç‡§§‡•á {memory['name']}! ‡§Æ‡•à‡§Ç ‡§ï‡•à‡§∏‡•á ‡§Æ‡§¶‡§¶ ‡§ï‡§∞‡•Ç‡§Å?"
        return "‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Æ‡•à‡§Ç RaazGPT ‡§π‡•Ç‡§Å ‚Äî ‡§™‡•Ç‡§õ‡§ø‡§è‡•§"

    # --- route ---
    def route(self, text):
        for pat, fn in self.patterns:
            m = pat.search(text)
            if m:
                return fn(m, text)
        return None


router = IntentRouter()

# ------------------ Answering logic ------------------

def try_exact_match(query):
    qn = normalize(query)
    for q, a in QA_LIST:
        if normalize(q) == qn:
            return a
    return None


def try_contains_match(query):
    qn = normalize(query)
    for q, a in QA_LIST:
        if normalize(q) in qn:
            return a
    return None


def try_fuzzy_match(query):
    # use difflib to find close question
    candidates = difflib.get_close_matches(query, QA_QUESTIONS, n=1, cutoff=FUZZY_THRESHOLD)
    if candidates:
        q = candidates[0]
        # get answer
        for _q, a in QA_LIST:
            if _q == q:
                return a
    return None


def try_math(query):
    m = re.search(r"(\d+)\s*([\+\-\*\/])\s*(\d+)", query)
    if not m:
        return None
    a = int(m.group(1)); op = m.group(2); b = int(m.group(3))
    try:
        if op == '+':
            return str(a + b)
        if op == '-':
            return str(a - b)
        if op == '*':
            return str(a * b)
        if op == '/':
            if b == 0:
                return "‡§∂‡•Ç‡§®‡•ç‡§Ø ‡§∏‡•á ‡§≠‡§æ‡§ó ‡§®‡§π‡•Ä‡§Ç ‡§π‡•ã ‡§∏‡§ï‡§§‡§æ"
            val = a / b
            return str(int(val)) if abs(val - round(val)) < 1e-9 else str(round(val, 2))
    except Exception:
        return None


def find_answer(query):
    if not query.strip():
        return "‡§ï‡•É‡§™‡§Ø‡§æ ‡§Ö‡§™‡§®‡§æ ‡§™‡•ç‡§∞‡§∂‡•ç‡§® ‡§≤‡§ø‡§ñ‡•á‡§Ç‡•§"

    # 0) commands / greetings
    routed = router.route(query.strip())
    if routed is not None:
        return routed

    # 1) exact
    ans = try_exact_match(query)
    if ans:
        return ans

    # 2) contains
    ans = try_contains_match(query)
    if ans:
        return ans

    # 3) math
    ans = try_math(query)
    if ans:
        return ans

    # 4) fuzzy
    ans = try_fuzzy_match(query)
    if ans:
        return ans

    # 5) triggers by keyword
    qn = normalize(query)
    if any(k in qn for k in ["‡§Æ‡§ú‡§æ‡§ï", "‡§ú‡•ã‡§ï"]):
        return "__JOKE__"
    if "‡§ó‡§æ‡§®‡§æ" in qn or "song" in qn:
        return "__SONG__"

    # 6) name memory hints
    if "‡§®‡§æ‡§Æ" in qn:
        if "‡§Æ‡•á‡§∞‡§æ ‡§®‡§æ‡§Æ" in qn:
            m = re.search(r"‡§Æ‡•á‡§∞‡§æ ‡§®‡§æ‡§Æ\s+([\w\-]+)", query, re.I)
            if m:
                name = m.group(1)
                memory["name"] = name
                save_memory()
                return f"‡§Ö‡§ö‡•ç‡§õ‡§æ {name}, ‡§Ü‡§™‡§∏‡•á ‡§Æ‡§ø‡§≤‡§ï‡§∞ ‡§ñ‡•Å‡§∂‡•Ä ‡§π‡•Å‡§à!"
        if memory.get("name"):
            return f"‡§Ü‡§™‡§ï‡§æ ‡§®‡§æ‡§Æ {memory['name']} ‡§π‡•à‡•§"
        return "‡§Æ‡•á‡§∞‡§æ ‡§®‡§æ‡§Æ RaazGPT ‡§π‡•à ‚Äî ‡§Ü‡§™‡§ï‡§æ ‡§∏‡§æ‡§•‡•Ä‡•§"

    return "‡§Æ‡§æ‡§´‡§º ‡§ï‡•Ä‡§ú‡§ø‡§è, ‡§Æ‡•à‡§Ç ‡§∏‡§Æ‡§ù ‡§®‡§π‡•Ä‡§Ç ‡§™‡§æ‡§Ø‡§æ ‚Äî ‡§ï‡•É‡§™‡§Ø‡§æ ‡§¶‡•Ç‡§∏‡§∞‡§æ ‡§§‡§∞‡•Ä‡§ï‡§æ ‡§Ü‡§ú‡§º‡§Æ‡§æ‡§è‡§Å ‡§Ø‡§æ /help ‡§≤‡§ø‡§ñ‡•á‡§Ç‡•§"

# ------------------ GUI Helpers ------------------
ui_queue = queue.Queue()


def add_chat_line(text):
    chatbox.config(state=tk.NORMAL)
    chatbox.insert(tk.END, text + "\n")
    chatbox.config(state=tk.DISABLED)
    chatbox.see(tk.END)


def clear_chat():
    chatbox.config(state=tk.NORMAL)
    chatbox.delete(1.0, tk.END)
    chatbox.config(state=tk.DISABLED)


chat_log = []  # for export


def post_system(text):
    chat_log.append(f"ü§ñ: {text}")
    add_chat_line("ü§ñ: " + text)


def post_user(text):
    chat_log.append(f"‡§Ü‡§™: {text}")
    add_chat_line("‡§Ü‡§™: " + text)


def export_chat():
    try:
        ts = time.strftime("%Y%m%d_%H%M%S")
        default = f"chat_{ts}.txt"
        path = filedialog.asksaveasfilename(defaultextension=".txt", initialfile=default,
                                            filetypes=[("Text Files", "*.txt"), ("All Files", "*.*")])
        if not path:
            return "Export ‡§∞‡§¶‡•ç‡§¶ ‡§ï‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ‡•§"
        with open(path, "w", encoding="utf-8") as f:
            f.write("\n".join(chat_log))
        return f"Exported: {os.path.basename(path)}"
    except Exception as e:
        return f"Export ‡§µ‡§ø‡§´‡§≤: {e}"


# ------------------ Conversation flow ------------------

def process_and_respond(user_text):
    ans = find_answer(user_text)
    memory["stats"]["messages"] = memory.get("stats", {}).get("messages", 0) + 1
    save_memory()

    if ans == "__JOKE__":
        j = random.choice(jokes)
        ui_queue.put(("bot", j))
        ui_queue.put(("speak", j))
        memory["stats"]["jokes"] += 1
        save_memory()
        return
    if ans == "__SONG__":
        s = random.choice(songs)
        ui_queue.put(("bot", s))
        ui_queue.put(("speak", s))
        memory["stats"]["songs"] += 1
        save_memory()
        return

    ui_queue.put(("bot", str(ans)))
    ui_queue.put(("speak", str(ans)))


def on_send_click(event=None):
    txt = entry.get().strip()
    if not txt:
        return
    entry.delete(0, tk.END)
    post_user(txt)
    threading.Thread(target=process_and_respond, args=(txt,), daemon=True).start()


def on_voice_click():
    if not SR_AVAILABLE:
        messagebox.showinfo("Voice not available", "SpeechRecognition library ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡•Ä ‡§Ø‡§æ ‡§Æ‡§æ‡§á‡§ï‡•ç‡§∞‡•ã‡§´‡§º‡•ã‡§® ‡§â‡§™‡§≤‡§¨‡•ç‡§ß ‡§®‡§π‡•Ä‡§Ç‡•§")
        return
    post_system("üé§ Listening‚Ä¶")

    def _listen():
        q = listen(timeout=5, phrase_time_limit=6)
        if not q:
            ui_queue.put(("bot", "‡§Æ‡•à‡§Ç ‡§∏‡•Å‡§® ‡§®‡§π‡•Ä‡§Ç ‡§™‡§æ‡§Ø‡§æ‡•§"))
            return
        ui_queue.put(("user", q))
        process_and_respond(q)

    threading.Thread(target=_listen, daemon=True).start()


def on_quit():
    save_memory()
    root.destroy()


def ui_pump():
    try:
        while True:
            kind, payload = ui_queue.get_nowait()
            if kind == "bot":
                post_system(payload)
            elif kind == "user":
                post_user(payload)
            elif kind == "speak":
                if TTS_AVAILABLE:
                    threading.Thread(target=speak, args=(payload,), daemon=True).start()
    except queue.Empty:
        pass
    root.after(60, ui_pump)

# ------------------ Build GUI ------------------
root = tk.Tk()
root.title("RaazGPT ‚Äî Offline GK + Jokes + Songs (v2)")
root.geometry("880x600")

# Menu
menubar = tk.Menu(root)
filemenu = tk.Menu(menubar, tearoff=0)
filemenu.add_command(label="Export Chat (/export)", command=lambda: post_system(export_chat()))
filemenu.add_separator()
filemenu.add_command(label="Quit", command=on_quit)
menubar.add_cascade(label="File", menu=filemenu)

helpmenu = tk.Menu(menubar, tearoff=0)
helpmenu.add_command(label="Help (/help)", command=lambda: post_system(router.intent_help(None, "")))
menubar.add_cascade(label="Help", menu=helpmenu)
root.config(menu=menubar)

chatbox = scrolledtext.ScrolledText(root, wrap=tk.WORD, width=100, height=28, font=("Arial", 12))
chatbox.config(state=tk.DISABLED)
chatbox.pack(padx=8, pady=8, fill=tk.BOTH, expand=True)

frame = tk.Frame(root)
frame.pack(pady=6)

entry = tk.Entry(frame, font=("Arial", 12), width=70)
entry.grid(row=0, column=0, padx=6)

send_btn = tk.Button(frame, text="Send", width=10, command=on_send_click)
send_btn.grid(row=0, column=1, padx=4)

voice_btn = tk.Button(frame, text="üéôÔ∏è Voice", width=10, command=on_voice_click, state=(tk.NORMAL if SR_AVAILABLE else tk.DISABLED))
voice_btn.grid(row=0, column=2, padx=4)

# Shortcuts
root.bind('<Return>', on_send_click)
root.bind('<Control-s>', lambda e: post_system(export_chat()))
root.bind('<F2>', lambda e: on_voice_click())

welcome = "‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Æ‡•à‡§Ç RaazGPT (v2) ‚Äî Offline GK + Jokes + Songs ‡§¨‡•â‡§ü. /help ‡§≤‡§ø‡§ñ‡§ï‡§∞ ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§¶‡•á‡§ñ‡•á‡§Ç‡•§"
post_system(welcome)
if TTS_AVAILABLE:
    threading.Thread(target=speak, args=(welcome,), daemon=True).start()

root.protocol("WM_DELETE_WINDOW", on_quit)
root.after(80, ui_pump)

# ------------------ Start GUI loop ------------------
root.mainloop()
